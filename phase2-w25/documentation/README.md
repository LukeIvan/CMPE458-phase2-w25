## Parser Documentation
=====================

### Introduction

This parser is designed to construct an Abstract Syntax Tree (AST) from a token stream generated by a custom lexical analyzer. It supports basic syntax elements such as variable declarations, assignments, and various statement types. This documentation outlines the implementation details, including operator precedence and specific function implementations.

### Project Structure

The parser is part of a larger project structure that includes:

- **include/**: Contains header files for tokens, lexer interface, and parser definitions.
- **src/**: Holds the implementation files for the lexer and parser.
- **test/**: Includes test files for validating parser functionality.

### Implemented Features

#### 1. **Variable Declarations**

   - **Syntax**: `int x;`
   - **Implementation**: The `parse_declaration` function creates an AST node for variable declarations by consuming the `int` keyword, expecting an identifier, and ensuring a semicolon at the end.

#### 2. **Assignments**

   - **Syntax**: `x = 5;`
   - **Implementation**: The `parse_assignment` function handles assignments by creating an AST node, consuming the identifier, expecting an equals sign, parsing the right-hand side expression, and ensuring a semicolon.

#### 3. **Expression Parsing**

   - **Current Support**: Basic expressions involving numbers and identifiers.
   - **Future Enhancements**:
     - **Binary Operations**: Implementing support for `+`, `-`, `*`, `/`.
     - **Comparison Operators**: Adding support for ``, `==`, etc.
     - **Parentheses Grouping**: Allowing expressions to be grouped with parentheses.
     - **Operator Precedence**: Ensuring correct order of operations (e.g., multiplication before addition).

#### 4. **Statement Types**

   - **If Statements**: `if (condition) { statements }`
   - **While Loops**: `while (condition) { statements }`
   - **Repeat-Until**: `repeat { statements } until (condition)`
   - **Print Statements**: `print expression;`
   - **Blocks**: `{ statement1; statement2; }`

#### 5. **Factorial Function**

   - **Syntax**: `factorial(x)`
   - **Implementation**: The `parse_factorial` function creates an AST node for factorial expressions by consuming the `factorial` keyword and parsing the enclosed expression.

### Operator Precedence

The parser currently supports basic expressions with the following operator precedence:

| Operator | Precedence |
|----------|------------|
| `*`, `/` | High       |
| `+`, `-` | Medium     |
| ``, `==`, etc. | Low        |

To implement operator precedence, the parser uses a recursive descent approach:

- **Multiplication and Division**: Handled first in `parse_multiplication`.
- **Addition and Subtraction**: Handled next in `parse_addition`, which calls `parse_multiplication`.
- **Comparison Operators**: Will be implemented similarly, ensuring they are evaluated last.

### Error Handling

The parser includes a basic error handling framework:

- **Error Types**: Defined in `parse_error` function, including unexpected tokens, missing semicolons, identifiers, equals signs, etc.
- **Error Reporting**: Errors are reported with line information and a description of the issue.
- **Future Enhancements**: Implementing error recovery to continue parsing after encountering errors.

### AST Structure

The Abstract Syntax Tree is constructed using nodes that represent different syntactic elements:

- **Node Types**: Include `AST_VARDECL`, `AST_ASSIGN`, `AST_IF`, `AST_WHILE`, `AST_PRINT`, `AST_FACTORIAL`, etc.
- **Node Creation**: The `create_node` function initializes new AST nodes with the appropriate type and token information.

### Testing and Debugging
- **Test Cases**: Provided in `test/` directory to validate parser functionality.
- Include filepath when running the binary compiled via CMake.
### Conclusion

This parser provides a foundational structure for parsing a custom programming language. It supports basic syntax elements and includes a framework for extending its capabilities. Future enhancements will focus on completing the implementation of all planned features and optimizing performance.